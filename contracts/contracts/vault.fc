;; CopyTrading Vault Contract in FunC
;; This contract allows users to deposit TON and automatically copy trades from a designated trader

#include "imports/stdlib.fc";

;; --- Operation Codes ---
;; op_deposit = 0x01
;; op_withdraw = 0x02
;; op_mirror_trade = 0x03
;; op_update_profit = 0x04
;; op_emergency_pause = 0x05

;; --- Error Codes ---
;; error_insufficient_balance = 101
;; error_invalid_amount = 102
;; error_unauthorized = 103
;; error_paused = 104

;; --- Data Layout ---
;; Storage: [ trader_address, owner_address, total_shares, total_assets, total_profit, is_paused, balances_dict, trade_history_dict ]

;; --- Receive External Messages ---
() recv_external(slice in_msg) {
    ;; Accept no-op for initialization
    accept_message();
}

;; --- Receive Internal Messages ---
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return (); ;; Accept simple transfers
    }

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    ;; Parse sender address
    var cs = in_msg_full.begin_parse();
    var flags = cs~load_uint(4);
    slice sender_addr = cs~load_msg_addr();

    ;; Load storage inline
    var ds = get_data().begin_parse();
    var trader = ds~load_msg_addr();
    var owner = ds~load_msg_addr();
    var total_shares = ds~load_uint(64);
    var total_assets = ds~load_coins();
    var total_profit = ds~load_coins();
    var is_paused = ds~load_uint(1);
    var balances = ds~load_dict();
    var trade_history = ds~load_dict();

    ;; Check if paused
    throw_if(104, (is_paused == 1) & (op != 0x05));

    if (op == 0x01) { ;; op_deposit
        ;; User deposits TON to get vault shares
        throw_if(102, msg_value <= 0);

        int user_hash = slice_hash(sender_addr);
        int shares = 0;

        if ((total_shares == 0) | (total_assets == 0)) {
            ;; First deposit: 1:1 ratio
            shares = msg_value;
        } else {
            ;; Calculate shares based on current ratio
            shares = muldiv(msg_value, total_shares, total_assets);
        }

        ;; Get old shares
        int old_shares = 0;
        var (val, found) = balances.udict_get?(256, user_hash);
        if (found) {
            old_shares = val~load_uint(64);
        }

        ;; Update balances
        balances = balances.udict_set_builder(256, user_hash, begin_cell().store_uint(old_shares + shares, 64));

        total_shares += shares;
        total_assets += msg_value;

        ;; Save storage inline
        set_data(begin_cell()
            .store_slice(trader)
            .store_slice(owner)
            .store_uint(total_shares, 64)
            .store_coins(total_assets)
            .store_coins(total_profit)
            .store_uint(is_paused, 1)
            .store_dict(balances)
            .store_dict(trade_history)
            .end_cell());
        return ();
    }

    if (op == 0x02) { ;; op_withdraw
        ;; User withdraws by burning shares
        int shares_to_burn = in_msg_body~load_uint(64);
        int user_hash = slice_hash(sender_addr);

        ;; Get user shares
        int user_shares = 0;
        var (val, found) = balances.udict_get?(256, user_hash);
        if (found) {
            user_shares = val~load_uint(64);
        }
        throw_if(101, user_shares < shares_to_burn);

        ;; Calculate withdrawal amount based on current vault value
        int amount = muldiv(shares_to_burn, total_assets, total_shares);

        ;; Update balances
        balances = balances.udict_set_builder(256, user_hash, begin_cell().store_uint(user_shares - shares_to_burn, 64));
        total_shares -= shares_to_burn;
        total_assets -= amount;

        ;; Send TON back to user
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender_addr)
            .store_coins(amount)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .end_cell();
        send_raw_message(msg, 1);

        ;; Save storage inline
        set_data(begin_cell()
            .store_slice(trader)
            .store_slice(owner)
            .store_uint(total_shares, 64)
            .store_coins(total_assets)
            .store_coins(total_profit)
            .store_uint(is_paused, 1)
            .store_dict(balances)
            .store_dict(trade_history)
            .end_cell());
        return ();
    }

    if (op == 0x03) { ;; op_mirror_trade
        ;; Only trader can trigger mirror trades
        throw_unless(103, equal_slices_bits(sender_addr, trader));

        ;; Parse trade details
        int trade_type = in_msg_body~load_uint(8);
        int trade_amount = in_msg_body~load_coins();
        slice token_addr = in_msg_body~load_msg_addr();

        ;; Calculate proportional trade amount based on vault assets
        ;; If vault has assets, execute trade proportionally
        if (total_assets > 0) {
            ;; Execute the trade by sending a message to DEX or token contract
            ;; For MVP: Send TON to token address as a simple swap simulation
            var trade_msg = begin_cell()
                .store_uint(0x18, 6)
                .store_slice(token_addr)
                .store_coins(trade_amount)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_uint(0, 32) ;; Simple transfer
                .end_cell();
            
            ;; Send trade message with mode 1 (pay fees separately)
            send_raw_message(trade_msg, 1);
            
            ;; Update total assets based on trade
            if (trade_type == 0) { ;; Buy
                ;; Buying tokens: decrease TON assets
                total_assets -= trade_amount;
            } else { ;; Sell
                ;; Selling tokens: increase TON assets
                total_assets += trade_amount;
            }
        }

        ;; Store trade in history
        int trade_id = now();
        trade_history = trade_history.udict_set_builder(64, trade_id,
            begin_cell()
                .store_uint(trade_type, 8)
                .store_coins(trade_amount)
                .store_slice(token_addr)
        );

        ;; Save storage inline
        set_data(begin_cell()
            .store_slice(trader)
            .store_slice(owner)
            .store_uint(total_shares, 64)
            .store_coins(total_assets)
            .store_coins(total_profit)
            .store_uint(is_paused, 1)
            .store_dict(balances)
            .store_dict(trade_history)
            .end_cell());
        return ();
    }

    if (op == 0x04) { ;; op_update_profit
        ;; Only trader or owner can update profit
        throw_unless(103, equal_slices_bits(sender_addr, trader) | equal_slices_bits(sender_addr, owner));

        int new_profit = in_msg_body~load_coins();
        total_profit = new_profit;

        ;; Save storage inline
        set_data(begin_cell()
            .store_slice(trader)
            .store_slice(owner)
            .store_uint(total_shares, 64)
            .store_coins(total_assets)
            .store_coins(total_profit)
            .store_uint(is_paused, 1)
            .store_dict(balances)
            .store_dict(trade_history)
            .end_cell());
        return ();
    }

    if (op == 0x05) { ;; op_emergency_pause
        ;; Only owner can pause/unpause
        throw_unless(103, equal_slices_bits(sender_addr, owner));

        is_paused = ~ is_paused;

        ;; Save storage inline
        set_data(begin_cell()
            .store_slice(trader)
            .store_slice(owner)
            .store_uint(total_shares, 64)
            .store_coins(total_assets)
            .store_coins(total_profit)
            .store_uint(is_paused, 1)
            .store_dict(balances)
            .store_dict(trade_history)
            .end_cell());
        return ();
    }

    ;; Unknown operation
    throw(0xffff);
}

;; --- Getters ---
(int, int, int, int, slice, slice) get_vault_data() method_id {
    var ds = get_data().begin_parse();
    var trader = ds~load_msg_addr();
    var owner = ds~load_msg_addr();
    var total_shares = ds~load_uint(64);
    var total_assets = ds~load_coins();
    var total_profit = ds~load_coins();
    var is_paused = ds~load_uint(1);
    return (total_shares, total_assets, total_profit, is_paused, trader, owner);
}

int get_user_shares(slice user_addr) method_id {
    var ds = get_data().begin_parse();
    ds~load_msg_addr(); ;; skip trader
    ds~load_msg_addr(); ;; skip owner
    ds~load_uint(64); ;; skip total_shares
    ds~load_coins(); ;; skip total_assets
    ds~load_coins(); ;; skip total_profit
    ds~load_uint(1); ;; skip is_paused
    var balances = ds~load_dict();
    
    int user_hash = slice_hash(user_addr);
    var (val, found) = balances.udict_get?(256, user_hash);
    if (found) {
        return val~load_uint(64);
    }
    return 0;
}

int get_user_balance_value(slice user_addr) method_id {
    var ds = get_data().begin_parse();
    ds~load_msg_addr(); ;; skip trader
    ds~load_msg_addr(); ;; skip owner
    var total_shares = ds~load_uint(64);
    var total_assets = ds~load_coins();
    ds~load_coins(); ;; skip total_profit
    ds~load_uint(1); ;; skip is_paused
    var balances = ds~load_dict();
    
    int user_hash = slice_hash(user_addr);
    var (val, found) = balances.udict_get?(256, user_hash);
    int user_shares = 0;
    if (found) {
        user_shares = val~load_uint(64);
    }
    
    if (total_shares == 0) {
        return 0;
    }
    
    return muldiv(user_shares, total_assets, total_shares);
}

int get_total_profit() method_id {
    var ds = get_data().begin_parse();
    ds~load_msg_addr(); ;; skip trader
    ds~load_msg_addr(); ;; skip owner
    ds~load_uint(64); ;; skip total_shares
    ds~load_coins(); ;; skip total_assets
    var total_profit = ds~load_coins();
    return total_profit;
}
