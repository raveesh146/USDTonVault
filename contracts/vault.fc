;; CopyTrading Vault Contract in FunC
;; This contract allows users to deposit TON and automatically copy trades from a designated trader

#include "imports/stdlib.fc"

;; --- Operation Codes ---
;; op_deposit = 0x01
;; op_withdraw = 0x02
;; op_mirror_trade = 0x03
;; op_update_profit = 0x04
;; op_emergency_pause = 0x05

;; --- Error Codes ---
;; error_insufficient_balance = 101
;; error_invalid_amount = 102
;; error_unauthorized = 103
;; error_paused = 104

;; --- Data Layout ---
;; Storage: [ trader_address, owner_address, total_shares, total_assets, total_profit, is_paused, balances_dict, trade_history_dict ]

;; Load storage
(slice, slice, int, int, int, int, cell, cell) load_data() inline_ref {
    slice ds = get_data().begin_parse();
    return (ds~load_msg_addr(), ds~load_msg_addr(), ds~load_uint(64), ds~load_coins(), ds~load_coins(), ds~load_uint(1), ds~load_dict(), ds~load_dict());
}

() save_data(slice trader, slice owner, int total_shares, int total_assets, int total_profit, int is_paused, cell balances, cell trade_history) impure inline_ref {
    set_data(begin_cell()
        .store_slice(trader)
        .store_slice(owner)
        .store_uint(total_shares, 64)
        .store_coins(total_assets)
        .store_coins(total_profit)
        .store_uint(is_paused, 1)
        .store_dict(balances)
        .store_dict(trade_history)
        .end_cell());
}

;; Get user balance (shares)
int get_user_shares(cell balances, int user_hash) {
    var (val, found) = balances.udict_get?(256, user_hash);
    if (found) {
        return val~load_uint(64);
    }
    return 0;
}

;; Set user balance (shares)
cell set_user_shares(cell balances, int user_hash, int shares) {
    return balances.udict_set_builder(256, user_hash, begin_cell().store_uint(shares, 64));
}

;; Calculate user hash from address
int calc_user_hash(slice user_addr) {
    return slice_hash(user_addr);
}

;; --- Receive External Messages ---
() recv_external(slice in_msg) impure {
    ;; Accept no-op for initialization
    accept_message();
}

;; --- Receive Internal Messages ---
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return (); ;; Accept simple transfers
    }

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    ;; Parse sender address
    var cs = in_msg_full.begin_parse();
    var flags = cs~load_uint(4);
    slice sender_addr = cs~load_msg_addr();

    ;; Load storage
    var (trader, owner, total_shares, total_assets, total_profit, is_paused, balances, trade_history) = load_data();

    ;; Check if paused
    throw_if(104, (is_paused == 1) & (op != 0x05));

    if (op == 0x01) { ;; op_deposit
        ;; User deposits TON to get vault shares
        throw_if(102, msg_value <= 0);

        int user_hash = calc_user_hash(sender_addr);
        int shares = 0;

        if ((total_shares == 0) | (total_assets == 0)) {
            ;; First deposit: 1:1 ratio
            shares = msg_value;
        } else {
            ;; Calculate shares based on current ratio
            shares = muldiv(msg_value, total_shares, total_assets);
        }

        int old_shares = get_user_shares(balances, user_hash);
        balances = set_user_shares(balances, user_hash, old_shares + shares);

        total_shares += shares;
        total_assets += msg_value;

        save_data(trader, owner, total_shares, total_assets, total_profit, is_paused, balances, trade_history);
        return ();
    }

    if (op == 0x02) { ;; op_withdraw
        ;; User withdraws by burning shares
        int shares_to_burn = in_msg_body~load_uint(64);
        int user_hash = calc_user_hash(sender_addr);

        int user_shares = get_user_shares(balances, user_hash);
        throw_if(101, user_shares < shares_to_burn);

        ;; Calculate withdrawal amount based on current vault value
        int amount = muldiv(shares_to_burn, total_assets, total_shares);

        balances = set_user_shares(balances, user_hash, user_shares - shares_to_burn);
        total_shares -= shares_to_burn;
        total_assets -= amount;

        ;; Send TON back to user
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender_addr)
            .store_coins(amount)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .end_cell();
        send_raw_message(msg, 1); ;; mode 1: pay fees separately

        save_data(trader, owner, total_shares, total_assets, total_profit, is_paused, balances, trade_history);
        return ();
    }

    if (op == 0x03) { ;; op_mirror_trade
        ;; Only trader can trigger mirror trades
        throw_unless(103, equal_slices(sender_addr, trader));

        ;; Parse trade details
        int trade_type = in_msg_body~load_uint(8); ;; 0=buy, 1=sell
        int trade_amount = in_msg_body~load_coins();
        slice token_addr = in_msg_body~load_msg_addr();

        ;; Store trade in history
        int trade_id = now();
        trade_history = trade_history.udict_set_builder(64, trade_id,
            begin_cell()
                .store_uint(trade_type, 8)
                .store_coins(trade_amount)
                .store_slice(token_addr)
        );

        ;; TODO: Execute actual DEX trade here
        ;; For MVP, just log the trade

        save_data(trader, owner, total_shares, total_assets, total_profit, is_paused, balances, trade_history);
        return ();
    }

    if (op == 0x04) { ;; op_update_profit
        ;; Only trader or owner can update profit
        throw_unless(103, equal_slices(sender_addr, trader) | equal_slices(sender_addr, owner));

        int new_profit = in_msg_body~load_coins();
        total_profit = new_profit;

        save_data(trader, owner, total_shares, total_assets, total_profit, is_paused, balances, trade_history);
        return ();
    }

    if (op == 0x05) { ;; op_emergency_pause
        ;; Only owner can pause/unpause
        throw_unless(103, equal_slices(sender_addr, owner));

        is_paused = ~ is_paused; ;; Toggle pause state

        save_data(trader, owner, total_shares, total_assets, total_profit, is_paused, balances, trade_history);
        return ();
    }

    ;; Unknown operation
    throw(0xffff);
}

;; --- Getters ---
(int, int, int, int, slice, slice) get_vault_data() method_id {
    var (trader, owner, total_shares, total_assets, total_profit, is_paused, balances, trade_history) = load_data();
    return (total_shares, total_assets, total_profit, is_paused, trader, owner);
}

int get_user_shares(slice user_addr) method_id {
    var (trader, owner, total_shares, total_assets, total_profit, is_paused, balances, trade_history) = load_data();
    int user_hash = calc_user_hash(user_addr);
    return get_user_shares(balances, user_hash);
}

int get_user_balance_value(slice user_addr) method_id {
    var (trader, owner, total_shares, total_assets, total_profit, is_paused, balances, trade_history) = load_data();
    if (total_shares == 0) {
        return 0;
    }
    int user_hash = calc_user_hash(user_addr);
    int user_shares = get_user_shares(balances, user_hash);
    return muldiv(user_shares, total_assets, total_shares);
}

int get_total_profit() method_id {
    var (trader, owner, total_shares, total_assets, total_profit, is_paused, balances, trade_history) = load_data();
    return total_profit;
}
